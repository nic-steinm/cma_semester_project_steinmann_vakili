---
title: Assessing the effectiveness of the "Wildschweinschreck" boar deterrence device at different distances.  
subtitle: A subtle subtitle
author: Nicolas Steinmann and Marjan Vakili
output: html_document

---


<!-- You can add  your R Code with Code chunks-->

```{r, echo = FALSE, warning=FALSE, message=FALSE}

# You can set chunk options individually per code chunk, as was done with this
# code chunk.

# echo = FALSE           hides the code from the generated output
# warning = FALSE        hides warnings from the generated output
# message = FALSE        hides messages from the generated output

# To set the setting for all code chunks, use the following code:

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

```


## Abstract

<!-- the following is just a placeholder text, remove it!-->
Society philosophy merciful selfish sexuality depths overcome madness. Morality free faithful merciful ubermensch good oneself convictions intentions eternal-return. Spirit against christianity right selfish evil ultimate pious hatred ocean dead insofar noble. Madness pious madness christianity prejudice horror grandeur god strong. Ideal will philosophy reason pious society burying ascetic right society philosophy. Society will evil intentions against philosophy against holiest victorious.


## Introduction

<!-- the following is just a placeholder text, remove it!-->
Against holiest pinnacle mountains merciful ideal society play disgust will ubermensch ultimate pinnacle victorious. Snare value law gains battle pious intentions revaluation strong. Insofar snare faith ideal oneself.

<!-- the following is just a placeholder text, remove it!-->
Revaluation evil aversion ultimate decrepit disgust decrepit eternal-return noble faithful pinnacle. Truth ascetic inexpedient decrepit free. Ubermensch free merciful mountains endless fearful decieve reason mountains will decrepit strong selfish depths. Overcome faith snare gains oneself transvaluation.


##Material and Methods

#Packages used:

Prominently used in this project are the dplyr, lubridate, sf, sp, tmap, shiny and ggplot packages.

```{r}
library(devtools)
library(terra)
library(ggplot2)
library(tmap)
library(sp)
library(readr)
library(shiny)
library(lubridate)
library(dplyr)
library(tibble)
library(sf)
library(ComputationalMovementAnalysisData)
```

#Datasets used:

For this analysis we used the datasets provided by our course tutors. Naturally, we needed all the boar location data of the survey area which could conveniently be loaded into the R-scripts with the provided "ComputationalMovementAnalysis"-package. Similarly, the wss_locations and the agenda were loaded into our inital data processing and filtering script.

```{r}
head(schreck_agenda)
head(schreck_locations)
head(wildschwein_BE)
```

#Pre-Processing:

The Wildschweinschreck locations first needed to be reprojected as they initally were provided in the WGS 84 geometric projection. The LV95 metric coordinates were then written into two seperate columns, E and N. In the next step, the locations were joined with the agenda. As some devices were activated multiple times at the exact same location, there are more entries in the agenda-table and thus the joined table has more entries than the original location table. A filter was applied to remove the deterrence devices activated in late Fall, Winter and early Spring. We wanted to observe the behavior of individuals during the vegetation period set between May and September. The Wildschweinschreck serves to protect crops so it made sense to filter it this way.

```{r}

#Step 1: Preprocessing the Wildschweinschreck location data

locations_sf <- st_as_sf(schreck_locations, coords = c('lon', 'lat'), crs = 4326)

#Reprojecting to LV95 metric coordinates
lv95_coords <- locations_sf%>%
  st_transform(crs = 2056)%>%
  mutate(E = st_coordinates(.)[,1],
         N = st_coordinates(.)[,2])

#Joining agenda and locations and filtering by date
joined_tables_device_locs <- left_join(lv95_coords, schreck_agenda , by = c("id" = "id"))%>%
  mutate(datum_on = as_datetime(paste(as.character(datum_on), " 00:01:00")),
        datum_off = as_datetime(paste(as.character(datum_off), " 00:01:00")))%>%
  filter(as.integer(month(datum_on)) >= 5  &  as.integer(month(datum_on)) <= 9)

joined_tables_device_locs <- st_set_geometry(joined_tables_device_locs, NULL)

```

The boar location data set contains more than 300'000 entries or location fixes in its raw form and not all of them are of use for this analysis. Here we also applied a filter to remove all the day time fixes, as boars typically feed in the cover of the night and the Wildschweinschreck devices were also only active after dark. Secondly, the fixes between November and March were excluded, this was done for the same reason as for the WSS location data, a longer time frame was included however, so that there were definitely enough fixes to compare the before and after state with the active state for all the device locations. This filtering left us with still more than 100'000 fixes to work with. For the remaining data velocity was calculated for each location, this gives us another movement variable to work with other than point density.

```{r}
#PRELIMINARY CODE: Step 2: Preprocessing boar location data
boar_locs_filtered <- wildschwein_BE%>% 
  filter(hour(DatetimeUTC) <= 6  |  hour(DatetimeUTC) >= 20)%>%
  filter(month(DatetimeUTC) >= 4 & month(DatetimeUTC) <= 10)

#Saving them in a .csv for convenience
write.csv(joined_tables_device_locs, file = "data/device_locations_filtered.csv")
write.csv(boar_locs_filtered, file = "data/boar_locations_filtered.csv")

``` 

#Processing:

As the data was now ready, the algorithm for our analysis could be implemented. We first planned to use geometric operations with spatial features, but as our calculations are mostly based around distance measures, we were able to get by with simple pythagorean math. As a first step, a distance calculation function was defined to make the following code a bit more tidy. Then, the desired range parameters in metres are defined. 

```{r}

#Defining functions
wss_distance <- function(x1, y1, x2, y2){
  sqrt((x1-x2)^2+(y1-y2)^2)
} 

  
#Defining distance parameters in metres, loading data
r1 = 50
r2 = 100
r3 = 500

#Reading in pre-processed data
wss_data <- read_delim("data/device_locations_filtered.csv", delim = ",")
boar_data <- read_delim("data/boar_locations_filtered.csv", delim = ",")
```

The Algorithm:

What sounds intimidating at first is in fact quite simple. Before the calculation begins, the areas of the range classes are calculated, again using simple geometric area functions. Three circles are calculated according to the range class input, then the area of the second biggest circle gets subtracted by the area of the biggest circle and-so-forth. In the end we receive the area in hectares of the donut-shaped range classes around each device. This will be handy for later statistics. For the results of our algorithm, some empty columns are created; The n- prefix stands for absolute amount and the rho- prefix representing relative density, these will be filled up later on.

```{r}
#PRELIMINARY CODE: PLEASE UPDATE BEFORE FINALISING REPORT
#Running the algorithm for switched on wildschweinschreck

#area sizes of range classes in ha
area_r1 <- round(((r1^2*pi) / 10000), 3)
area_r2 <- round((((r2^2*pi) - area_r1) / 10000), 3)
area_r3 <- round((((r3^2*pi) - (r2^2*pi)) / 10000), 3)

#add columns for the results of the calculations
wss_data <- wss_data %>%
  add_column(r1 = r1,
             r2 = r2,
             r3 = r3,
             a_r1 = area_r1,
             a_r2 = area_r2,
             a_r3 = area_r3,
             n_r1_on = 0,
             n_r2_on = 0,
             n_r3_on = 0,
             rho_r1_on = 0,
             rho_r2_on = 0,
             rho_r3_on = 0)
```

The core range-class algorithm consists of a single loop that iterates through the WSS location table rows. Based on the information (location, time of activation/shutdown) contained in each row about the corresponding location, the large boar location dataset is manipulated. For each iteration, the data is filtered for the time interval during which the device was running, then the euclidian distance of these fixes to the respective device location is calculated and written into the boar location table. 

Based on the distances, the boar location dataset can be subsetted based on the distance ranges provided in the beginning. The number of fixes in each range class is counted and written into the corresponding data field of the Wildschweinschreck table. With the area of each range class it is also possible to calculate the density of the fixes. This is then devided by the number of days the device was active so the densities are more  comparable with each other since every device on the schedule runs for a different amount of time. The data in the relative rho- fields thus is in the unit of fixes per hectar and day.

```{r}
  for (i in 1:nrow(wss_data)){
    E_wss <- wss_data$E[i]
    N_wss <- wss_data$N[i]
    wss_start <- wss_data$datum_on[i]
    wss_end <- wss_data$datum_off[i]
    n_days <- as.numeric(difftime(wss_end, wss_start, units = "days"))
  
    boar_data_filtered <- boar_data%>%
      filter(DatetimeUTC >= wss_start & DatetimeUTC <= wss_end)%>%
      mutate(dist = wss_distance(E_wss, N_wss, E, N))
    
    #aggregating fixes based on distance to device
    fixes_r1 <- boar_data_filtered%>%
      filter(dist <= r1)
    fixes_r2 <- boar_data_filtered%>%
      filter(dist > r1 & dist <= r2)
    fixes_r3 <- boar_data_filtered%>%
      filter(dist > r2 & dist <= r3)
  
    #number of fixes in each range class and specified time interval
    wss_data$n_r1_on[i] <- nrow(fixes_r1)
    wss_data$n_r2_on[i] <- nrow(fixes_r2)
    wss_data$n_r3_on[i] <- nrow(fixes_r3)
  
    #boar density per hectare and day, to make relative numbers comparable
    wss_data$rho_r1_on[i] <- round((wss_data$n_r1_on[i]/area_r1)/n_days, 2)
    wss_data$rho_r2_on[i] <- round((wss_data$n_r2_on[i]/area_r2)/n_days, 2)
    wss_data$rho_r3_on[i] <- round((wss_data$n_r3_on[i]/area_r3)/n_days, 2)
    }

```

Despite the seemingly vast amount of location data, many boars seemed not to have been in the right place at the right time, as most range classes did not contain any fixes at all. These are of no use to our analysis and need to be discarded. This leaves only eight out of the initial 61 WSS locations to work with. 

```{r}

#filtering data entries with no boar locations in r1, r2 and r3
wss_data <- wss_data%>%
  filter(n_r1_on != 0 & n_r2_on != 0 & n_r3_on != 0)

head(wss_data)
```

Now we need a "control group" to compare against that reflects the boar movement without the effects of a deterrence device. For this we used a timeframe of the same length as the active state of each device (datum_off - datum_on) but immediately before device activation. The temporal closeness was chosen to keep as many factors as possible constant, such the as the season, presence of the same individuals and a similar food supply. Of course there are some insecurities because of this and other factors that might influence boar behavior.

Some more columns were created for the data to be written in and some temporal parameters were changed. Apart from the that, the same loop was run another time and also provided the same stats for this time frame. 


```{r}
#Running the algorithm for time before switched on

wss_data <- wss_data %>%
  add_column(n_r1_bon = 0, # -bon suffix stands for "before on"
             n_r2_bon = 0,
             n_r3_bon = 0,
             rho_r1_bon = 0,
             rho_r2_bon = 0,
             rho_r3_bon = 0)


for (i in 1:nrow(wss_data)){
  E_wss <- wss_data$E[i]
  N_wss <- wss_data$N[i]
  wss_start <- wss_data$datum_on[i] - as.numeric(wss_data$datum_off[i] - wss_data$datum_on[i])*86400 #using the same time interval for before as during       device activation
  wss_end <- wss_data$datum_on[i]
  n_days <- as.numeric(difftime(wss_end, wss_start, units = "days"))
  
  boar_data_filtered <- boar_data%>%
    filter(DatetimeUTC >= wss_start & DatetimeUTC <= wss_end)%>%
    mutate(dist = wss_distance(E_wss, N_wss, E, N))
  
  fixes_r1 <- boar_data_filtered%>%
    filter(dist <= r1)
  fixes_r2 <- boar_data_filtered%>%
    filter(dist > r1 & dist <= r2)
  fixes_r3 <- boar_data_filtered%>%
    filter(dist > r2 & dist <= r3)
  
  #number of fixes in each range class and specified time interval
  wss_data$n_r1_bon[i] <- nrow(fixes_r1)
  wss_data$n_r2_bon[i] <- nrow(fixes_r2)
  wss_data$n_r3_bon[i] <- nrow(fixes_r3)
  
  #boar density per hectare and day
  wss_data$rho_r1_bon[i] <- round((wss_data$n_r1_bon[i]/area_r1)/n_days, 2)
  wss_data$rho_r2_bon[i] <- round((wss_data$n_r2_bon[i]/area_r2)/n_days, 2)
  wss_data$rho_r3_bon[i] <- round((wss_data$n_r3_bon[i]/area_r3)/n_days, 2)
}

#Saving to csv for convenience
write.csv(wss_data, file = "data/range_class_data.csv")

```
## Results

<!-- the following is just a placeholder text, remove it!-->
Philosophy oneself passion play fearful self noble zarathustra deceptions sexuality. Endless ocean of oneself dead ocean. Selfish decrepit.

## Discussion

<!-- the following is just a placeholder text, remove it!-->
Justice convictions spirit sexuality insofar free marvelous joy. Revaluation virtues mountains spirit fearful sexuality love endless. Society intentions will noble burying aversion moral. Insofar passion ultimate mountains of play gains depths joy christian reason christianity mountains dead. Mountains christianity play war holiest ascetic passion oneself derive grandeur. Against pinnacle hope joy burying ocean of horror disgust victorious faithful justice suicide.

